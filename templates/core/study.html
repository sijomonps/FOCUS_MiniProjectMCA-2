{% extends 'base.html' %}
{% load static %}

{% block title %}Focus Timer - FOCUS{% endblock %}

{% block extra_css %}
<style>
    /* Ultra Minimal Timer Layout */
    .timer-page {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: calc(100vh - 100px);
        padding: 2rem;
    }

    /* Duration Presets */
    .duration-presets {
        display: flex;
        gap: 12px;
        margin-bottom: 3rem;
        flex-wrap: wrap;
        justify-content: center;
    }

    .preset-btn {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        padding: 12px 24px;
        border-radius: 50px;
        font-size: 0.95rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .preset-btn:hover {
        border-color: var(--text-secondary);
        color: var(--text-primary);
    }

    .preset-btn.active {
        background: var(--text-primary);
        color: var(--bg-primary);
        border-color: var(--text-primary);
    }

    .preset-btn.custom-active {
        background: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }

    /* Stopwatch button style */
    .stopwatch-btn {
        border-color: var(--color-green);
        color: var(--color-green);
    }

    .stopwatch-btn:hover {
        background: rgba(102, 153, 119, 0.15);
        border-color: var(--color-green);
        color: var(--color-green);
    }

    .stopwatch-btn.active {
        background: var(--color-green);
        color: white;
        border-color: var(--color-green);
    }

    .stopwatch-btn i {
        margin-right: 4px;
    }

    /* Custom Duration Input */
    .custom-input-wrapper {
        display: none;
        align-items: center;
        gap: 8px;
        margin-top: 1rem;
    }

    .custom-input-wrapper.show {
        display: flex;
    }

    .custom-input {
        width: 80px;
        padding: 10px 16px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 25px;
        color: var(--text-primary);
        font-size: 1rem;
        text-align: center;
    }

    .custom-input:focus {
        outline: none;
        border-color: var(--primary-color);
    }

    .custom-label {
        color: var(--text-secondary);
        font-size: 0.9rem;
    }

    /* Timer Display */
    .timer-display {
        font-size: 8rem;
        font-weight: 200;
        color: var(--text-primary);
        font-variant-numeric: tabular-nums;
        line-height: 1;
        margin-bottom: 1rem;
        letter-spacing: -4px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    }

    .timer-mode-label {
        color: var(--text-tertiary);
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 2rem;
    }

    @media (max-width: 768px) {
        .timer-display {
            font-size: 4.5rem;
            letter-spacing: -2px;
        }

        .timer-page {
            min-height: calc(100vh - 150px);
            padding: 1rem;
        }

        .duration-presets {
            gap: 8px;
        }

        .preset-btn {
            padding: 10px 18px;
            font-size: 0.85rem;
        }
    }

    /* Subject Select - Minimal */
    .subject-select-wrapper {
        margin-bottom: 2rem;
        width: 100%;
        max-width: 280px;
    }

    .subject-select {
        width: 100%;
        padding: 14px 24px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 50px;
        color: var(--text-primary);
        font-size: 1rem;
        cursor: pointer;
        appearance: none;
        text-align: center;
        transition: all 0.2s;
    }

    .subject-select:focus {
        outline: none;
        border-color: var(--primary-color);
    }

    .subject-select option {
        background: var(--bg-secondary);
        color: var(--text-primary);
    }

    /* Control Buttons */
    .controls {
        display: flex;
        gap: 16px;
        align-items: center;
    }

    .main-btn {
        background: var(--text-primary);
        color: var(--bg-primary);
        border: none;
        padding: 18px 56px;
        font-size: 1rem;
        font-weight: 600;
        border-radius: 50px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 2px;
        transition: all 0.2s ease;
    }

    .main-btn:hover {
        transform: scale(1.02);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
    }

    .main-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    .main-btn.running {
        background: var(--color-red);
        color: white;
    }

    .reset-btn {
        background: transparent;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        padding: 18px 32px;
        font-size: 0.9rem;
        font-weight: 500;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .reset-btn:hover {
        border-color: var(--text-secondary);
        color: var(--text-primary);
    }

    /* Picture-in-Picture Button */
    .pip-btn {
        background: transparent;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        padding: 18px 24px;
        font-size: 0.9rem;
        font-weight: 500;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.2s;
        display: none;
    }

    .pip-btn:hover {
        border-color: var(--primary-color);
        color: var(--primary-color);
    }

    .pip-btn.active {
        border-color: var(--primary-color);
        color: var(--primary-color);
        background: rgba(79, 70, 229, 0.1);
    }

    .pip-btn i {
        font-size: 1.1rem;
    }

    /* Session Complete Message */
    .session-complete {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        flex-direction: column;
        gap: 24px;
    }

    .session-complete.show {
        display: flex;
    }

    .session-complete h2 {
        font-size: 2.5rem;
        font-weight: 300;
        color: var(--text-primary);
    }

    .session-complete p {
        color: var(--text-secondary);
        font-size: 1.1rem;
    }

    .session-complete button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 16px 48px;
        font-size: 1rem;
        border-radius: 50px;
        cursor: pointer;
        margin-top: 1rem;
    }

    /* Recorded Sessions - Minimal */
    .recorded-info {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        color: var(--text-tertiary);
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .recorded-dot {
        width: 6px;
        height: 6px;
        background: var(--color-green);
        border-radius: 50%;
    }

    /* Today's Study Time Indicator */
    .today-study-indicator {
        position: fixed;
        top: 1.5rem;
        right: 1.5rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        padding: 10px 16px;
        border-radius: 50px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9rem;
        color: var(--text-secondary);
        box-shadow: var(--shadow-md);
        z-index: 100;
    }

    .today-study-indicator i {
        color: var(--color-green);
        font-size: 1.1rem;
    }

    .today-study-indicator span:last-child {
        color: var(--color-green);
        font-weight: 600;
    }

    @media (max-width: 768px) {
        .today-study-indicator {
            top: auto;
            bottom: 5rem;
            right: 1rem;
            padding: 8px 12px;
            font-size: 0.8rem;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="timer-page fade-in">

    <!-- Study Greeting -->
    <div style="text-align: center; margin-bottom: 2rem; color: var(--text-secondary); font-size: 1.1rem; font-weight: 500;" data-dynamic-greeting="study">
        {{ greeting }}
    </div>

    <!-- Duration Presets -->
    <div class="duration-presets">
        <button class="preset-btn" data-duration="25" onclick="selectDuration(25, this)">25 min</button>
        <button class="preset-btn" data-duration="45" onclick="selectDuration(45, this)">45 min</button>
        <button class="preset-btn" data-duration="60" onclick="selectDuration(60, this)">60 min</button>
        <button class="preset-btn" data-duration="90" onclick="selectDuration(90, this)">90 min</button>
        <button class="preset-btn" data-duration="custom" onclick="toggleCustomInput(this)">Custom</button>
        <button class="preset-btn stopwatch-btn" data-duration="stopwatch" onclick="selectStopwatch(this)">
            <i class="mdi mdi-timer-outline"></i> Stopwatch
        </button>
    </div>

    <!-- Custom Duration Input -->
    <div class="custom-input-wrapper" id="customInputWrapper">
        <input type="number" class="custom-input" id="customMinutes" min="1" max="180" placeholder="30">
        <span class="custom-label">minutes</span>
        <button class="preset-btn" onclick="applyCustomDuration()" style="padding: 10px 20px;">Set</button>
    </div>

    <!-- Timer Display -->
    <div class="timer-display" id="timerDisplay">25:00</div>
    <div class="timer-mode-label" id="timerModeLabel">Focus Session</div>

    <!-- Subject Select -->
    <div class="subject-select-wrapper">
        <select class="subject-select" id="subjectSelect">
            <option value="" disabled selected>Select subject...</option>
            {% for subject in subjects %}
            <option value="{{ subject }}">{{ subject }}</option>
            {% endfor %}
        </select>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="main-btn" id="mainBtn" onclick="toggleTimer()">Start</button>
        <button class="reset-btn" id="resetBtn" onclick="resetTimer()">Reset</button>
        <button class="pip-btn" id="pipBtn" onclick="togglePiP()" title="Picture-in-Picture (Auto-activates when you switch tabs)">
            <i class="mdi mdi-picture-in-picture-top-right"></i>
        </button>
    </div>

</div>

<!-- Hidden canvas for PiP rendering -->
<canvas id="pipCanvas" width="400" height="200" style="position: fixed; top: -500px; left: 0; z-index: -1;"></canvas>
<video id="pipVideo" width="400" height="200" style="position: fixed; top: -500px; left: 0; z-index: -1;" muted playsinline></video>

<!-- Session Complete Overlay -->
<div class="session-complete" id="sessionComplete">
    <h2>ðŸŽ‰ Session Complete!</h2>
    <p id="sessionSummary">You focused for 25 minutes</p>
    <div id="streakInfo" style="margin: 10px 0; color: #22c55e; font-weight: 500;">
        <i class="mdi mdi-fire" style="margin-right: 4px;"></i>
        <span id="streakText">Streak: {{ current_streak }} day{{ current_streak|pluralize }}</span>
        {% if highest_streak > 0 %}
        <div style="font-size: 0.85rem; color: #94a3b8; margin-top: 4px;">
            <i class="mdi mdi-trophy" style="color: #f59e0b;"></i> Best: {{ highest_streak }} day{{ highest_streak|pluralize }}
        </div>
        {% endif %}
    </div>
    <button onclick="closeComplete()">Continue</button>
    <button onclick="goToDashboard()" style="margin-left: 12px; background: transparent; border: 1px solid #4f46e5; color: #4f46e5;">View Dashboard</button>
</div>

<!-- Recorded Sessions Indicator -->
<div class="recorded-info" id="recordedInfo" style="display: none;">
    <span class="recorded-dot"></span>
    <span id="recordedText">Session recorded</span>
</div>

<!-- Today's Study Time Indicator (Study Page) -->
<div class="today-study-indicator" id="todayStudyIndicator">
    <i class="mdi mdi-clock-check-outline"></i>
    <span>Today: </span>
    <span id="todayStudyTime">0m</span>
</div>

{% endblock %}

{% block extra_js %}
<script>
    // Timer Configuration
    let selectedDuration = 25 * 60; // Default 25 minutes in seconds
    let remainingTime = selectedDuration;
    let timerInterval = null;
    let isRunning = false;
    let sessionStartTime = null;
    let totalFocusedTime = 0;
    let timerEndTime = null; // Timestamp when timer should end
    
    // Stopwatch mode
    let isStopwatchMode = false;
    let stopwatchStartTime = null;
    let elapsedTime = 0; // Elapsed seconds for stopwatch

    // DOM Elements
    const timerDisplay = document.getElementById('timerDisplay');
    const timerModeLabel = document.getElementById('timerModeLabel');
    const mainBtn = document.getElementById('mainBtn');
    const resetBtn = document.getElementById('resetBtn');
    const subjectSelect = document.getElementById('subjectSelect');
    const customInputWrapper = document.getElementById('customInputWrapper');
    const customMinutesInput = document.getElementById('customMinutes');
    const sessionComplete = document.getElementById('sessionComplete');
    const sessionSummary = document.getElementById('sessionSummary');
    const recordedInfo = document.getElementById('recordedInfo');
    const globalTimerContainer = document.getElementById('globalTimerContainer');
    const globalTimerDisplay = document.getElementById('globalTimerDisplay');

    // ========================================
    // Today's Study Time Helper Functions
    // ========================================
    
    // Sync with server to get today's actual total from database
    async function syncTodayStudyTimeFromServer() {
        try {
            const response = await fetch('/api/study/today/');
            const data = await response.json();
            if (data.success) {
                const serverMinutes = data.today_total_minutes || 0;
                const key = getTodayDateKey();
                localStorage.setItem(key, serverMinutes.toString());
                updateTodayStudyDisplay();
                console.log(`Synced with server. Today's total: ${serverMinutes} minutes`);
                return serverMinutes;
            }
        } catch (error) {
            console.error('Error syncing with server:', error);
        }
        return getTodayStudyMinutes(); // Return local value as fallback
    }
    
    function getTodayDateKey() {
        const now = new Date();
        return `studyTime_${now.getFullYear()}_${now.getMonth()}_${now.getDate()}`;
    }

    function getTodayStudyMinutes() {
        const key = getTodayDateKey();
        const saved = localStorage.getItem(key);
        return saved ? parseInt(saved) : 0;
    }

    function addTodayStudyMinutes(minutes) {
        const key = getTodayDateKey();
        const current = getTodayStudyMinutes();
        const newTotal = current + minutes;
        localStorage.setItem(key, newTotal.toString());

        // Clean up old entries
        cleanupOldStudyData();

        // Update the display in sidebar
        updateTodayStudyDisplay();

        return newTotal;
    }

    function cleanupOldStudyData() {
        const todayKey = getTodayDateKey();
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('studyTime_') && key !== todayKey) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
    }

    function formatStudyTime(minutes) {
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        if (hours > 0) {
            return `${hours}h ${mins}m`;
        }
        return `${mins}m`;
    }

    function updateTodayStudyDisplay() {
        const savedMinutes = getTodayStudyMinutes();

        // Calculate active session time if timer is running or paused with progress
        let activeSessionMinutes = 0;
        
        if (isStopwatchMode) {
            // Stopwatch mode - use elapsed time
            if (isRunning && stopwatchStartTime) {
                activeSessionMinutes = Math.floor(elapsedTime / 60);
            } else if (!isRunning && elapsedTime > 0) {
                // Paused stopwatch
                activeSessionMinutes = Math.floor(elapsedTime / 60);
            }
        } else {
            // Countdown mode
            if (isRunning && timerEndTime && selectedDuration) {
                // Timer is running - calculate elapsed time
                const now = Date.now();
                const remaining = Math.max(0, Math.floor((timerEndTime - now) / 1000));
                const elapsed = selectedDuration - remaining;
                activeSessionMinutes = Math.floor(elapsed / 60);
            } else if (!isRunning && totalFocusedTime > 0) {
                // Timer is paused - use accumulated totalFocusedTime
                activeSessionMinutes = Math.floor(totalFocusedTime / 60);
            }
        }

        const totalMinutes = savedMinutes + activeSessionMinutes;
        const formattedTime = formatStudyTime(totalMinutes);

        // Update sidebar display
        const sidebarDisplay = document.getElementById('todayStudyDisplay');
        if (sidebarDisplay) {
            sidebarDisplay.textContent = formattedTime;
        }

        // Update study page indicator with live tracking
        const pageIndicator = document.getElementById('todayStudyTime');
        const todayIndicator = document.getElementById('todayStudyIndicator');
        if (pageIndicator) {
            pageIndicator.textContent = formattedTime;

            // Add visual indicator when timer is active or paused with progress
            const hasActiveSession = isStopwatchMode ? (isRunning || elapsedTime > 0) : (isRunning || totalFocusedTime > 0);
            if (todayIndicator && hasActiveSession) {
                todayIndicator.style.borderColor = isRunning ? 'var(--color-green)' : 'var(--color-yellow)';
                todayIndicator.style.boxShadow = isRunning
                    ? '0 0 12px rgba(102, 153, 119, 0.3)'
                    : '0 0 12px rgba(204, 187, 102, 0.3)';
            } else if (todayIndicator) {
                todayIndicator.style.borderColor = '';
                todayIndicator.style.boxShadow = '';
            }
        }
    }

    // Save timer state to localStorage for persistence across pages
    function saveTimerState() {
        const state = {
            isRunning: isRunning,
            timerEndTime: timerEndTime,
            selectedDuration: selectedDuration,
            remainingTime: remainingTime,
            subject: subjectSelect.value,
            totalFocusedTime: totalFocusedTime,
            sessionStartTime: sessionStartTime,
            // Stopwatch specific
            isStopwatchMode: isStopwatchMode,
            stopwatchStartTime: stopwatchStartTime,
            elapsedTime: elapsedTime
        };
        localStorage.setItem('focusTimerState', JSON.stringify(state));
    }

    // Load timer state from localStorage
    function loadTimerState() {
        const savedState = localStorage.getItem('focusTimerState');
        if (savedState) {
            try {
                const state = JSON.parse(savedState);
                
                // Check for stopwatch mode
                if (state.isStopwatchMode) {
                    isStopwatchMode = true;
                    
                    // Update button state
                    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active', 'custom-active'));
                    const stopwatchBtn = document.querySelector('.stopwatch-btn');
                    if (stopwatchBtn) stopwatchBtn.classList.add('active');
                    
                    if (state.isRunning && state.stopwatchStartTime) {
                        // Stopwatch is running
                        stopwatchStartTime = state.stopwatchStartTime;
                        elapsedTime = Math.floor((Date.now() - stopwatchStartTime) / 1000);
                        isRunning = true;
                        sessionStartTime = state.sessionStartTime;
                        
                        if (state.subject) {
                            subjectSelect.value = state.subject;
                            subjectSelect.disabled = true;
                        }
                        
                        mainBtn.textContent = 'Stop';
                        mainBtn.classList.add('running');
                        timerModeLabel.textContent = 'Stopwatch Running...';
                        
                        updateDisplay();
                        updateGlobalTimer();
                        startStopwatchLoop();
                        return true;
                    } else if (!state.isRunning && state.elapsedTime > 0) {
                        // Stopwatch was paused
                        elapsedTime = state.elapsedTime;
                        totalFocusedTime = state.totalFocusedTime || elapsedTime;
                        
                        if (state.subject) {
                            subjectSelect.value = state.subject;
                        }
                        
                        mainBtn.textContent = 'Resume';
                        timerModeLabel.textContent = 'Stopwatch Paused';
                        updateDisplay();
                    } else {
                        // Just stopwatch mode selected, not started
                        timerDisplay.textContent = '0:00';
                        timerModeLabel.textContent = 'Stopwatch Mode';
                    }
                    return false;
                }
                
                // Original countdown timer logic
                if (state.isRunning && state.timerEndTime) {
                    const now = Date.now();
                    const remaining = Math.floor((state.timerEndTime - now) / 1000);

                    if (remaining > 0) {
                        // Timer still running - restore state
                        isRunning = true;
                        timerEndTime = state.timerEndTime;
                        selectedDuration = state.selectedDuration;
                        remainingTime = remaining;
                        totalFocusedTime = state.totalFocusedTime || 0;
                        sessionStartTime = state.sessionStartTime;

                        // Restore subject selection
                        if (state.subject) {
                            subjectSelect.value = state.subject;
                            subjectSelect.disabled = true;
                        }

                        // Update UI
                        mainBtn.textContent = 'Pause';
                        mainBtn.classList.add('running');
                        timerModeLabel.textContent = 'Focusing...';

                        // Update display immediately
                        updateDisplay();
                        updateGlobalTimer();

                        // Restart the timer loop
                        startTimerLoop();
                        return true;
                    } else {
                        // Timer has ended while away
                        if (state.subject) {
                            subjectSelect.value = state.subject;
                            selectedDuration = state.selectedDuration;
                            totalFocusedTime = state.selectedDuration;
                            remainingTime = 0;
                            timerComplete();
                        }
                        clearTimerState();
                    }
                } else if (!state.isRunning && state.subject) {
                    // Timer was paused - restore paused state
                    selectedDuration = state.selectedDuration || selectedDuration;
                    remainingTime = state.remainingTime || selectedDuration;
                    subjectSelect.value = state.subject;
                    totalFocusedTime = state.totalFocusedTime || 0;

                    if (totalFocusedTime > 0) {
                        mainBtn.textContent = 'Resume';
                        timerModeLabel.textContent = 'Paused';
                    }
                    updateDisplay();
                }
            } catch (e) {
                console.error('Error loading timer state:', e);
                clearTimerState();
            }
        }
        return false;
    }

    // Clear timer state
    function clearTimerState() {
        localStorage.removeItem('focusTimerState');
    }

    // Update global sidebar timer - sync with base.html's global timer
    function updateGlobalTimer() {
        // This triggers the global timer in base.html to update by re-saving state
        // The base.html interval will pick up the changes
        if (globalTimerContainer && globalTimerDisplay) {
            if (isStopwatchMode) {
                // Stopwatch mode - always show when running or has elapsed time
                if (isRunning || elapsedTime > 0) {
                    globalTimerContainer.classList.remove('hidden');
                    globalTimerDisplay.textContent = formatTime(elapsedTime);
                } else {
                    globalTimerContainer.classList.add('hidden');
                }
            } else {
                // Countdown mode
                if (isRunning && remainingTime > 0) {
                    globalTimerContainer.classList.remove('hidden');
                    globalTimerDisplay.textContent = formatTime(remainingTime);
                } else {
                    globalTimerContainer.classList.add('hidden');
                }
            }
        }
    }

    // Format time as MM:SS (always showing total minutes, not hours)
    // For focus timers, users prefer seeing "60:00" rather than "1:00:00"
    function formatTime(seconds) {
        const totalMinutes = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${totalMinutes}:${s < 10 ? '0' : ''}${s}`;
    }

    // Select Duration Preset (countdown mode)
    function selectDuration(minutes, btn) {
        if (isRunning) return;

        // Exit stopwatch mode
        isStopwatchMode = false;
        elapsedTime = 0;
        stopwatchStartTime = null;

        // Update button states
        document.querySelectorAll('.preset-btn').forEach(b => {
            b.classList.remove('active', 'custom-active');
        });
        btn.classList.add('active');

        // Hide custom input
        customInputWrapper.classList.remove('show');

        // Set duration
        selectedDuration = minutes * 60;
        remainingTime = selectedDuration;
        timerModeLabel.textContent = 'Focus Session';
        updateDisplay();
    }

    // Select Stopwatch Mode (count up)
    function selectStopwatch(btn) {
        if (isRunning) return;

        // Enter stopwatch mode
        isStopwatchMode = true;
        elapsedTime = 0;
        stopwatchStartTime = null;

        // Update button states
        document.querySelectorAll('.preset-btn').forEach(b => {
            b.classList.remove('active', 'custom-active');
        });
        btn.classList.add('active');

        // Hide custom input
        customInputWrapper.classList.remove('show');

        // Update display for stopwatch
        timerDisplay.textContent = '0:00';
        timerModeLabel.textContent = 'Stopwatch Mode';
    }

    // Toggle Custom Input
    function toggleCustomInput(btn) {
        if (isRunning) return;

        // Exit stopwatch mode
        isStopwatchMode = false;

        document.querySelectorAll('.preset-btn').forEach(b => {
            b.classList.remove('active');
        });

        customInputWrapper.classList.toggle('show');

        if (customInputWrapper.classList.contains('show')) {
            btn.classList.add('custom-active');
            customMinutesInput.focus();
        } else {
            btn.classList.remove('custom-active');
        }
    }

    // Apply Custom Duration
    function applyCustomDuration() {
        isStopwatchMode = false;
        const minutes = parseInt(customMinutesInput.value);
        if (minutes && minutes > 0 && minutes <= 180) {
            selectedDuration = minutes * 60;
            remainingTime = selectedDuration;
            updateDisplay();
            customInputWrapper.classList.remove('show');
        }
    }

    // Update Timer Display
    function updateDisplay() {
        if (isStopwatchMode) {
            timerDisplay.textContent = formatTime(elapsedTime);
            if (isRunning) {
                document.title = `(${formatTime(elapsedTime)}) Stopwatch - FOCUS`;
            } else {
                document.title = 'Focus Timer - FOCUS';
            }
        } else {
            timerDisplay.textContent = formatTime(remainingTime);
            if (isRunning) {
                document.title = `(${formatTime(remainingTime)}) Focus - FOCUS`;
            } else {
                document.title = 'Focus Timer - FOCUS';
            }
        }
    }

    // Toggle Timer (Start/Pause)
    function toggleTimer() {
        console.log('toggleTimer called');
        console.log('Subject selected:', subjectSelect.value);
        console.log('Is running:', isRunning);
        console.log('Is stopwatch mode:', isStopwatchMode);

        if (!subjectSelect.value) {
            alert('Please select a subject before starting.');
            return;
        }

        if (isRunning) {
            console.log('Pausing timer');
            pauseTimer();
        } else {
            console.log('Starting timer');
            startTimer();
        }
    }

    // Start Timer
    function startTimer() {
        if (isStopwatchMode) {
            // Stopwatch mode - count up
            isRunning = true;
            sessionStartTime = Date.now();
            
            // If resuming, calculate start time to account for already elapsed time
            if (elapsedTime > 0) {
                stopwatchStartTime = Date.now() - (elapsedTime * 1000);
            } else {
                stopwatchStartTime = Date.now();
            }
            
            mainBtn.textContent = 'Stop';
            mainBtn.classList.add('running');
            timerModeLabel.textContent = 'Stopwatch Running...';
            subjectSelect.disabled = true;
            
            // Show PiP button when timer starts (if supported)
            if (pipSupported) {
                pipBtn.style.display = 'block';
            }
            
            saveTimerState();
            startStopwatchLoop();
        } else {
            // Countdown mode
            if (remainingTime <= 0) {
                remainingTime = selectedDuration;
            }

            isRunning = true;
            sessionStartTime = Date.now();
            timerEndTime = Date.now() + (remainingTime * 1000); // Calculate end time
            mainBtn.textContent = 'Pause';
            mainBtn.classList.add('running');
            timerModeLabel.textContent = 'Focusing...';
            subjectSelect.disabled = true;

            // Show PiP button when timer starts (if supported)
            if (pipSupported) {
                pipBtn.style.display = 'block';
            }

            saveTimerState();
            startTimerLoop();
        }
    }

    // Timer loop using timestamp-based calculation (works even when tab is inactive)
    function startTimerLoop() {
        clearInterval(timerInterval);

        timerInterval = setInterval(() => {
            const now = Date.now();
            remainingTime = Math.max(0, Math.floor((timerEndTime - now) / 1000));
            updateDisplay();
            updateGlobalTimer();
            updateTodayStudyDisplay(); // Live update today's study time
            saveTimerState();

            if (remainingTime <= 0) {
                timerComplete();
            }
        }, 100); // Update more frequently for accuracy
    }

    // Stopwatch loop - counts up
    function startStopwatchLoop() {
        clearInterval(timerInterval);

        timerInterval = setInterval(() => {
            const now = Date.now();
            elapsedTime = Math.floor((now - stopwatchStartTime) / 1000);
            updateDisplay();
            updateGlobalTimer();
            updateTodayStudyDisplay(); // Live update today's study time
            saveTimerState();
        }, 100); // Update frequently for smooth display
    }

    // Pause Timer
    function pauseTimer() {
        clearInterval(timerInterval);
        isRunning = false;
        
        if (isStopwatchMode) {
            // For stopwatch, we just pause - elapsedTime already holds current value
            mainBtn.textContent = 'Resume';
            mainBtn.classList.remove('running');
            timerModeLabel.textContent = 'Stopwatch Paused';
            
            // Calculate focused time so far
            if (sessionStartTime) {
                totalFocusedTime = elapsedTime;
                sessionStartTime = null;
            }
        } else {
            timerEndTime = null;
            mainBtn.textContent = 'Resume';
            mainBtn.classList.remove('running');
            timerModeLabel.textContent = 'Paused';

            // Calculate focused time so far
            if (sessionStartTime) {
                totalFocusedTime += Math.floor((Date.now() - sessionStartTime) / 1000);
                sessionStartTime = null;
            }
        }

        saveTimerState();
        updateGlobalTimer();
        updateTodayStudyDisplay(); // Keep today's study time updated when paused
        
        // Hide PiP button when paused
        if (pipSupported && pipBtn) {
            pipBtn.style.display = 'none';
        }
    }

    // Reset Timer
    function resetTimer() {
        clearInterval(timerInterval);
        isRunning = false;
        timerEndTime = null;

        // Exit PiP if active
        if (typeof pipActive !== 'undefined' && pipActive) {
            exitPiP();
        }
        pipManuallyActivated = false; // Reset flag on reset

        // Save session if any time was focused
        let focusedMinutes;
        if (isStopwatchMode) {
            focusedMinutes = Math.floor(elapsedTime / 60);
        } else {
            focusedMinutes = Math.floor(totalFocusedTime / 60);
        }
        
        if (focusedMinutes >= 1 && subjectSelect.value) {
            saveSession(focusedMinutes);
        }

        // Reset everything
        if (isStopwatchMode) {
            elapsedTime = 0;
            stopwatchStartTime = null;
            timerDisplay.textContent = '0:00';
            timerModeLabel.textContent = 'Stopwatch Mode';
        } else {
            remainingTime = selectedDuration;
            timerModeLabel.textContent = 'Focus Session';
        }
        
        totalFocusedTime = 0;
        sessionStartTime = null;
        mainBtn.textContent = 'Start';
        mainBtn.classList.remove('running');
        subjectSelect.disabled = false;
        updateDisplay();
        clearTimerState();
        updateGlobalTimer();
        
        // Hide PiP button
        if (pipSupported && pipBtn) {
            pipBtn.style.display = 'none';
        }
    }

    // Timer Complete
    function timerComplete() {
        clearInterval(timerInterval);
        isRunning = false;
        timerEndTime = null;

        // Exit PiP after a brief delay to show completion
        if (typeof pipActive !== 'undefined' && pipActive) {
            setTimeout(() => {
                exitPiP();
                pipManuallyActivated = false; // Reset flag after completion
            }, 2000);
        } else {
            pipManuallyActivated = false; // Reset flag if PiP not active
        }

        // Calculate total focused time
        if (sessionStartTime) {
            totalFocusedTime += Math.floor((Date.now() - sessionStartTime) / 1000);
            sessionStartTime = null;
        }

        // Use selected duration if totalFocusedTime is 0 (timer completed normally)
        if (totalFocusedTime === 0) {
            totalFocusedTime = selectedDuration;
        }

        const focusedMinutes = Math.floor(totalFocusedTime / 60);

        // Play completion sound
        playCompletionSound();

        // Show browser notification
        showNotification(focusedMinutes);

        // Save the session
        if (focusedMinutes >= 1) {
            saveSession(focusedMinutes);
        }

        // Show completion overlay
        sessionSummary.textContent = `You focused for ${focusedMinutes} minutes on ${subjectSelect.value}`;
        sessionComplete.classList.add('show');

        // Reset for next session
        mainBtn.textContent = 'Start';
        mainBtn.classList.remove('running');
        timerModeLabel.textContent = 'Session Complete!';
        subjectSelect.disabled = false;
        remainingTime = selectedDuration;
        totalFocusedTime = 0;
        updateDisplay();
        clearTimerState();
        updateGlobalTimer();
    }

    // Play Completion Sound - Gentle 3-tone chime
    function playCompletionSound() {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Play 3 gentle ascending tones
            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
            const delays = [0, 200, 400];

            frequencies.forEach((freq, i) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.6);
                }, delays[i]);
            });
        } catch (e) {
            console.log('Audio not supported');
        }
    }

    // Show Browser Notification
    function showNotification(minutes) {
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('Focus Session Complete! ðŸŽ‰', {
                body: `Great job! You focused for ${minutes} minutes.`,
                requireInteraction: true
            });
        }
    }

    // Request notification permission on load
    function requestNotificationPermission() {
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }
    }

    // Save Session to Backend
    async function saveSession(minutes) {
        const subject = subjectSelect.value;
        if (!subject || minutes < 1) return;

        try {
            const response = await fetch("{% url 'save_study_session' %}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({
                    subject: subject,
                    duration: minutes
                })
            });

            const data = await response.json();
            if (data.success) {
                showRecordedIndicator();
                
                // Update server-synced today's total from response
                if (data.today_total_minutes !== undefined) {
                    const key = getTodayDateKey();
                    localStorage.setItem(key, data.today_total_minutes.toString());
                    
                    // Update displays
                    updateTodayStudyDisplay();
                    
                    console.log(`Session saved: ${minutes} min. Server total today: ${data.today_total_minutes} min`);
                } else {
                    // Fallback to local addition if server doesn't return total
                    const totalToday = addTodayStudyMinutes(minutes);
                    console.log(`Session saved: ${minutes} min. Local total today: ${totalToday} min`);
                }
                
                // Update streak info in completion overlay
                if (data.current_streak !== undefined) {
                    updateStreakDisplay(data.current_streak);
                }
                
                // Update highest streak if provided and changed
                if (data.highest_streak !== undefined) {
                    updateHighestStreakDisplay(data.highest_streak);
                }
                
                // Signal dashboard to refresh when user navigates there
                localStorage.setItem('dashboardNeedsRefresh', Date.now().toString());
            } else {
                console.error('Server error saving session:', data.error);
            }
        } catch (e) {
            console.error('Failed to save session:', e);
            // Fallback to local tracking if server fails
            const totalToday = addTodayStudyMinutes(minutes);
            console.log(`Session saved locally: ${minutes} min. Total today: ${totalToday} min`);
        }
    }

    // Update streak display
    function updateStreakDisplay(streak) {
        const streakText = document.getElementById('streakText');
        if (streakText) {
            if (streak > 0) {
                streakText.textContent = `Streak: ${streak} day${streak !== 1 ? 's' : ''}`;
            } else {
                streakText.textContent = 'Start your streak today!';
            }
        }
        // Note: Highest streak display is kept static from initial page load
    }
    
    // Update highest streak display (called when user beats their record)
    function updateHighestStreakDisplay(highestStreak) {
        const streakInfo = document.getElementById('streakInfo');
        if (!streakInfo) return;
        
        // Check if highest streak div already exists
        let highestStreakDiv = streakInfo.querySelector('.highest-streak-display');
        
        if (highestStreak > 0) {
            if (highestStreakDiv) {
                // Update existing display
                highestStreakDiv.innerHTML = `<i class="mdi mdi-trophy" style="color: #f59e0b;"></i> Best: ${highestStreak} day${highestStreak !== 1 ? 's' : ''}`;
            } else {
                // Create new display
                highestStreakDiv = document.createElement('div');
                highestStreakDiv.className = 'highest-streak-display';
                highestStreakDiv.style = 'font-size: 0.85rem; color: #94a3b8; margin-top: 4px;';
                highestStreakDiv.innerHTML = `<i class="mdi mdi-trophy" style="color: #f59e0b;"></i> Best: ${highestStreak} day${highestStreak !== 1 ? 's' : ''}`;
                streakInfo.appendChild(highestStreakDiv);
            }
        }
    }

    // Go to dashboard
    function goToDashboard() {
        window.location.href = "{% url 'dashboard' %}";
    }

    // Show Recorded Indicator
    function showRecordedIndicator() {
        recordedInfo.style.display = 'flex';
        setTimeout(() => {
            recordedInfo.style.display = 'none';
        }, 3000);
    }

    // Close Completion Overlay
    function closeComplete() {
        sessionComplete.classList.remove('show');
    }

    // Handle Enter key in custom input
    customMinutesInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            applyCustomDuration();
        }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !e.target.matches('input, select')) {
            e.preventDefault();
            toggleTimer();
        }
        if (e.code === 'Escape') {
            closeComplete();
        }
    });

    // Save state before leaving - DON'T pause, just ensure state is saved
    window.addEventListener('beforeunload', () => {
        if (isRunning) {
            // Just save the current state - timer will continue based on timerEndTime
            saveTimerState();
        }
    });

    // Also save when navigating within the app (click on sidebar links)
    document.querySelectorAll('.sidebar-nav a').forEach(link => {
        link.addEventListener('click', () => {
            if (isRunning) {
                saveTimerState();
            }
        });
    });

    // Initialize
    requestNotificationPermission();

    // Sync today's study time with server on page load
    syncTodayStudyTimeFromServer();

    // Initialize today's study time display
    updateTodayStudyDisplay();

    // Try to restore timer state first
    const restored = loadTimerState();
    if (!restored) {
        updateDisplay();
        // Set first preset as active
        document.querySelector('.preset-btn[data-duration="25"]').classList.add('active');
    } else {
        // Update preset buttons to show correct selection
        document.querySelectorAll('.preset-btn').forEach(b => {
            b.classList.remove('active', 'custom-active');
            if (parseInt(b.dataset.duration) * 60 === selectedDuration) {
                b.classList.add('active');
            }
        });
        updateDisplay();
    }

    // Handle visibility change - Auto-enable PiP when tab is hidden, disable when visible
    document.addEventListener('visibilitychange', async () => {
        console.log('Tab visibility changed. Hidden:', document.hidden);
        console.log('  - isRunning:', isRunning);
        console.log('  - pipSupported:', pipSupported);
        console.log('  - pipActive:', pipActive);
        console.log('  - pipManuallyActivated:', pipManuallyActivated);
        
        if (document.hidden) {
            // Tab is hidden - automatically enable PiP if timer is running and PiP is supported
            if (isRunning && pipSupported && !pipActive) {
                console.log('=> Auto-enabling PiP (tab hidden)');
                await enterPiP(true); // Pass true for automatic activation
            } else {
                if (!isRunning) console.log('=> Not enabling PiP: timer not running');
                if (!pipSupported) console.log('=> Not enabling PiP: not supported');
                if (pipActive) console.log('=> PiP already active');
            }
        } else {
            // Tab is visible - close PiP if it was auto-activated (not manually)
            if (pipActive && !pipManuallyActivated) {
                console.log('=> Auto-disabling PiP (tab visible, was auto-activated)');
                await exitPiP();
            } else {
                if (!pipActive) console.log('=> PiP not active');
                if (pipManuallyActivated) console.log('=> Keeping PiP (manually activated)');
            }
            
            // Recalculate time when tab becomes visible
            if (isRunning && timerEndTime) {
                const now = Date.now();
                remainingTime = Math.max(0, Math.floor((timerEndTime - now) / 1000));
                updateDisplay();
                updateGlobalTimer();

                if (remainingTime <= 0) {
                    timerComplete();
                }
            }
        }
    });

    // ============================================
    // PICTURE-IN-PICTURE FUNCTIONALITY
    // ============================================
    
    let pipActive = false;
    let pipAnimationFrame = null;
    let pipManuallyActivated = false; // Track if user manually activated PiP
    const pipCanvas = document.getElementById('pipCanvas');
    const pipVideo = document.getElementById('pipVideo');
    const pipBtn = document.getElementById('pipBtn');
    const ctx = pipCanvas ? pipCanvas.getContext('2d') : null;
    let pipSupported = false;

    // Initialize canvas immediately with a test frame
    if (pipCanvas && ctx) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, pipCanvas.width, pipCanvas.height);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Timer Ready', pipCanvas.width / 2, pipCanvas.height / 2);
        console.log('Canvas initialized with test frame');
    }

    // Check if PiP is supported more thoroughly
    console.log('=== Picture-in-Picture Debug Info ===');
    console.log('Browser:', navigator.userAgent);
    console.log('pictureInPictureEnabled:', document.pictureInPictureEnabled);
    console.log('pipVideo element:', pipVideo ? 'Found' : 'NOT FOUND');
    console.log('pipCanvas element:', pipCanvas ? 'Found' : 'NOT FOUND');
    console.log('Canvas context:', ctx ? 'OK' : 'FAILED');
    
    if (document.pictureInPictureEnabled && pipVideo && pipCanvas && ctx) {
        pipSupported = true;
        console.log('âœ“ Picture-in-Picture is SUPPORTED');
        
        // Test if requestPictureInPicture exists on video element
        if (typeof pipVideo.requestPictureInPicture === 'function') {
            console.log('âœ“ requestPictureInPicture method available');
        } else {
            console.log('âœ— requestPictureInPicture method NOT available');
            pipSupported = false;
        }
    } else {
        console.log('âœ— Picture-in-Picture is NOT SUPPORTED');
        if (!document.pictureInPictureEnabled) {
            console.log('  - pictureInPictureEnabled is false or undefined');
        }
        if (!pipVideo) {
            console.log('  - pipVideo element not found');
        }
        if (!pipCanvas) {
            console.log('  - pipCanvas element not found');
        }
        if (!ctx) {
            console.log('  - Canvas context failed');
        }
    }
    console.log('=====================================');

    // Toggle Picture-in-Picture (manual toggle by user)
    async function togglePiP() {
        console.log('togglePiP called, pipActive:', pipActive);
        if (pipActive) {
            // Exit PiP
            pipManuallyActivated = false;
            await exitPiP();
        } else {
            // Enter PiP
            if (!pipSupported) {
                alert('Picture-in-Picture is not supported in your browser. Please use Chrome, Edge, or Safari.');
                return;
            }
            pipManuallyActivated = true;
            await enterPiP();
        }
    }

    // Enter Picture-in-Picture mode
    async function enterPiP(isAutomatic = false) {
        try {
            console.log('enterPiP: Starting...', isAutomatic ? '(AUTOMATIC)' : '(MANUAL)');
            
            if (!pipCanvas || !pipVideo || !ctx) {
                throw new Error('PiP elements not found');
            }
            
            // First, draw initial frame to canvas so it has content
            const width = pipCanvas.width;
            const height = pipCanvas.height;
            console.log('enterPiP: Canvas dimensions:', width, 'x', height);
            
            // Draw background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);
            
            // Draw timer time
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const timeText = isStopwatchMode ? formatTime(elapsedTime) : formatTime(remainingTime);
            ctx.fillText(timeText, width / 2, height / 2 - 20);
            
            // Draw subject
            const subject = subjectSelect.value || 'No Subject';
            ctx.fillStyle = '#94a3b8';
            ctx.font = '20px Arial';
            ctx.fillText(subject, width / 2, height / 2 + 40);
            console.log('enterPiP: Initial frame drawn to canvas');
            
            // Check if we already have a stream, if not create one
            if (!pipVideo.srcObject) {
                const stream = pipCanvas.captureStream(30); // 30 FPS
                console.log('enterPiP: Canvas stream captured, tracks:', stream.getTracks().length);
                
                if (stream.getTracks().length === 0) {
                    throw new Error('No tracks in canvas stream');
                }
                
                pipVideo.srcObject = stream;
                console.log('enterPiP: Video srcObject set');
            }
            
            // Ensure video is loaded and playing
            if (pipVideo.paused) {
                console.log('enterPiP: Starting video playback...');
                try {
                    await pipVideo.play();
                    console.log('enterPiP: Video playing');
                } catch (playError) {
                    console.error('enterPiP: Video play failed:', playError);
                    // Try to continue anyway
                }
            }
            
            // Small delay to ensure video is ready
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Request PiP
            console.log('enterPiP: Requesting Picture-in-Picture...');
            
            if (!pipVideo.requestPictureInPicture) {
                throw new Error('requestPictureInPicture not available');
            }
            
            await pipVideo.requestPictureInPicture();
            console.log('enterPiP: Picture-in-Picture activated!');
            
            pipActive = true;
            pipBtn.classList.add('active');
            
            // Start continuous rendering
            renderPiPFrame();
            console.log('enterPiP: Rendering started');
            
        } catch (error) {
            console.error('Failed to enter PiP:', error);
            console.error('Error name:', error.name);
            console.error('Error message:', error.message);
            console.error('Error stack:', error.stack);
            
            // Provide user-friendly error messages
            if (error.name === 'NotAllowedError') {
                if (!isAutomatic) {
                    alert('Picture-in-Picture was denied. Please allow it in your browser settings or try clicking the button again.');
                }
            } else if (error.name === 'NotSupportedError') {
                if (!isAutomatic) {
                    alert('Picture-in-Picture is not supported in this browser. Please use Chrome (version 70+), Edge (79+), or Safari (13.1+).');
                }
            } else {
                if (!isAutomatic) {
                    alert('Failed to start Picture-in-Picture: ' + error.message);
                }
            }
            
            // Cleanup on error
            pipActive = false;
            pipBtn.classList.remove('active');
            if (pipVideo.srcObject) {
                pipVideo.srcObject.getTracks().forEach(track => track.stop());
                pipVideo.srcObject = null;
            }
        }
    }

    // Exit Picture-in-Picture mode
    async function exitPiP() {
        try {
            console.log('exitPiP: Exiting PiP mode...');
            if (document.pictureInPictureElement) {
                await document.exitPictureInPicture();
                console.log('exitPiP: PiP exited');
            }
            
            pipActive = false;
            pipBtn.classList.remove('active');
            
            // Stop rendering
            if (pipAnimationFrame) {
                cancelAnimationFrame(pipAnimationFrame);
                pipAnimationFrame = null;
                console.log('exitPiP: Rendering stopped');
            }
            
            // Stop video stream
            if (pipVideo.srcObject) {
                pipVideo.srcObject.getTracks().forEach(track => track.stop());
                pipVideo.srcObject = null;
                console.log('exitPiP: Video stream stopped');
            }
            
        } catch (error) {
            console.error('Failed to exit PiP:', error);
        }
    }

    // Render timer to canvas for PiP
    function renderPiPFrame() {
        if (!pipActive) return;
        
        try {
            const width = pipCanvas.width;
            const height = pipCanvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);
            
            // Draw timer time
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const timeText = isStopwatchMode ? formatTime(elapsedTime) : formatTime(remainingTime);
            ctx.fillText(timeText, width / 2, height / 2 - 20);
            
            // Draw subject
            const subject = subjectSelect.value || 'No Subject';
            ctx.fillStyle = '#94a3b8';
            ctx.font = '20px Arial';
            ctx.fillText(subject, width / 2, height / 2 + 40);
            
            // Draw status indicator
            if (isRunning) {
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(30, 30, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ef4444';
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(isStopwatchMode ? 'RECORDING' : 'LIVE', 50, 35);
            } else {
                ctx.fillStyle = '#f59e0b';
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('PAUSED', 30, 35);
            }
            
            // Continue animation
            pipAnimationFrame = requestAnimationFrame(renderPiPFrame);
        } catch (error) {
            console.error('Error in renderPiPFrame:', error);
            // Stop rendering on error
            pipActive = false;
            if (pipAnimationFrame) {
                cancelAnimationFrame(pipAnimationFrame);
                pipAnimationFrame = null;
            }
        }
    }

    // Handle PiP events - cleanup when user exits PiP manually
    pipVideo.addEventListener('leavepictureinpicture', () => {
        console.log('User closed PiP window');
        pipActive = false;
        pipManuallyActivated = false; // Reset flag when user closes PiP
        pipBtn.classList.remove('active');
        if (pipAnimationFrame) {
            cancelAnimationFrame(pipAnimationFrame);
            pipAnimationFrame = null;
        }
    });

</script>
{% endblock %}